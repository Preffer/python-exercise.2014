// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var Spider, child_process, http, jsdom, numCPUs, sqlite3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  http = require('http');

  jsdom = require('jsdom');

  sqlite3 = require('sqlite3');

  child_process = require('child_process');

  numCPUs = require('os').cpus().length;

  Spider = (function() {
    function Spider() {
      this.getItemCount = __bind(this.getItemCount, this);
      this.queryProblems = __bind(this.queryProblems, this);
      this.selectAllProblems = __bind(this.selectAllProblems, this);
      this.parallelFetchAllProblems = __bind(this.parallelFetchAllProblems, this);
      this.storeProblem = __bind(this.storeProblem, this);
      this.fetchProblem = __bind(this.fetchProblem, this);
      this.serializeFetchAllProblems = __bind(this.serializeFetchAllProblems, this);
      this.afterFetch = __bind(this.afterFetch, this);
      this.prepareFetch = __bind(this.prepareFetch, this);
      this.fetchStoreProblem = __bind(this.fetchStoreProblem, this);
      this.getProblemMax = __bind(this.getProblemMax, this);
      this.getVoluemPathList = __bind(this.getVoluemPathList, this);
      this.getVolumeCount = __bind(this.getVolumeCount, this);
      this.run = __bind(this.run, this);
      this.db = new sqlite3.Database('data.db');
      this.db.run('CREATE VIRTUAL TABLE IF NOT EXISTS problems USING fts4(id, title, body)');
      this.baseUrl = 'http://acm.zju.edu.cn';
      this.indexPath = '/onlinejudge/showProblemsets.do';
      this.voluemPath = '/onlinejudge/showProblems.do?contestId=1&pageNumber=';
      this.problemPath = '/onlinejudge/showProblem.do?problemCode=';
      this.problemMin = 1001;
    }

    Spider.prototype.run = function(mode) {
      this.mode = mode;
      return this.getVolumeCount();
    };

    Spider.prototype.getVolumeCount = function() {
      return jsdom.env({
        url: this.baseUrl + this.indexPath,
        done: (function(_this) {
          return function(errors, window) {
            _this.voluemCount = window.document.querySelectorAll('#content_body > form:nth-child(1) > a').length;
            window.close();
            return _this.getProblemMax();
          };
        })(this)
      });
    };


    /*
    	this function is deprecated
    	because the problemID is continuous 
    	and we don't have to access the problem from the voluem page
    	just use problemPath and problemCode to access the problem
     */

    Spider.prototype.getVoluemPathList = function() {
      return jsdom.env({
        url: this.baseUrl + this.indexPath,
        done: (function(_this) {
          return function(errors, window) {
            _this.voluemPathList = window.document.querySelectorAll('#content_body > form:nth-child(1) > a')._toArray().map(function(item) {
              return item.getAttribute('href');
            });
            return window.close();
          };
        })(this)
      });
    };

    Spider.prototype.getProblemMax = function() {
      return jsdom.env({
        url: this.baseUrl + this.voluemPath + this.voluemCount,
        done: (function(_this) {
          return function(errors, window) {
            var $;
            $ = require('jquery')(window);
            _this.problemMax = $('#content_body > form:nth-child(1) > table > tr:last-child > td.problemId > a > font').text();
            _this.problemCount = _this.problemMax - _this.problemMin + 1;
            console.log("" + _this.problemCount + " Problems in total");
            window.close();
            if (_this.mode === 'parallel') {
              return _this.parallelFetchAllProblems();
            } else {
              return _this.serializeFetchAllProblems();
            }
          };
        })(this)
      });
    };

    Spider.prototype.fetchStoreProblem = function(id) {
      return jsdom.env({
        url: this.baseUrl + this.problemPath + id,
        done: (function(_this) {
          return function(errors, window) {
            var $, body, title;
            $ = require('jquery')(window);
            title = $('#content_body > center:nth-child(1) > span').text();
            body = $('#content_body').text();
            console.log("Now fetching ProblemID: " + id + ", Title: " + title);
            _this.stmt.run(id - _this.problemMin, id, title, body);
            _this.done++;
            window.close();
            if (_this.done === _this.problemCount) {
              return _this.afterFetch();
            }
          };
        })(this)
      });
    };

    Spider.prototype.prepareFetch = function() {
      this.db.serialize((function(_this) {
        return function() {
          _this.stmt = _this.db.prepare('INSERT OR REPLACE INTO problems (rowid, id, title, body) VALUES (?, ?, ?, ?)');
          return _this.db.run('BEGIN');
        };
      })(this));
      this.tpstart = Date.now();
      return this.done = 0;
    };

    Spider.prototype.afterFetch = function() {
      this.tpend = Date.now();
      console.log("Fetch data used " + ((this.tpend - this.tpstart) / 1000) + " s");
      console.log('Fetch data end, writing to database');
      this.tpstart = Date.now();
      this.db.serialize((function(_this) {
        return function() {
          _this.db.run('COMMIT');
          return _this.stmt.finalize();
        };
      })(this));
      return this.db.close((function(_this) {
        return function() {
          _this.tpend = Date.now();
          console.log("Wirte to database used " + ((_this.tpend - _this.tpstart) / 1000) + " s");
          return _this.exit();
        };
      })(this));
    };

    Spider.prototype.serializeFetchAllProblems = function() {
      var i, _i, _ref, _ref1, _results;
      this.prepareFetch();
      _results = [];
      for (i = _i = _ref = this.problemMin, _ref1 = this.problemMax; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
        _results.push(this.fetchStoreProblem(i));
      }
      return _results;
    };

    Spider.prototype.fetchProblem = function(id) {
      var req, url;
      url = this.baseUrl + this.problemPath + id;
      req = http.get(url, (function(_this) {
        return function(res) {
          var body;
          body = '';
          res.on('data', function(chunk) {
            return body += chunk;
          });
          return res.on('end', function() {
            console.log("Fetched ProblemID: " + id);
            return _this.child[id % numCPUs].send([id, body]);
          });
        };
      })(this));
      return req.on('error', function(e) {
        return console.log("problem with request: " + e.message);
      });
    };

    Spider.prototype.storeProblem = function(id, title, body) {
      this.stmt.run(id - this.problemMin, id, title, body);
      this.done++;
      if (this.done === this.problemCount) {
        return this.afterFetch();
      }
    };

    Spider.prototype.parallelFetchAllProblems = function() {
      var i, _i, _j, _ref, _ref1, _results;
      this.prepareFetch();
      this.child = [];
      for (i = _i = 0; 0 <= numCPUs ? _i < numCPUs : _i > numCPUs; i = 0 <= numCPUs ? ++_i : --_i) {
        this.child[i] = child_process.fork('./child.js');
        this.child[i].on('message', (function(_this) {
          return function(m) {
            return _this.storeProblem(m[0], m[1], m[2]);
          };
        })(this));
      }
      _results = [];
      for (i = _j = _ref = this.problemMin, _ref1 = this.problemMax; _ref <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = _ref <= _ref1 ? ++_j : --_j) {
        _results.push(this.fetchProblem(i));
      }
      return _results;
    };

    Spider.prototype.selectAllProblems = function() {
      return this.db.each('SELECT * FROM problems', function(err, row) {
        return console.log(row);
      });
    };

    Spider.prototype.queryProblems = function(keyword) {
      return this.db.each('SELECT id, title FROM problems WHERE body MATCH ?', keyword, (function(_this) {
        return function(err, row) {
          return console.log("ProblemID: " + row.id + ", Title: " + row.title + ", Link: " + (_this.baseUrl + _this.problemPath + row.id));
        };
      })(this), (function(_this) {
        return function(err, count) {
          console.log("" + count + " problems match your keyword");
          return _this.exit();
        };
      })(this));
    };

    Spider.prototype.getItemCount = function() {
      return this.db.get('SELECT COUNT(*) AS count FROM problems', function(error, row) {
        return console.log("Database have " + row.count + " problems stored now");
      });
    };

    Spider.prototype.exit = function() {
      return process.exit(0);
    };

    return Spider;

  })();

  exports.Spider = Spider;

}).call(this);
